/*
 * Commerce Platform API
 * RESTful API for the creation of Commerce Cases with Checkouts and the execution of Payments. 
 *
 * The version of the OpenAPI document: 1.5.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package client.api;

import com.fasterxml.jackson.core.type.TypeReference;

import java.util.UUID;


import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.StringJoiner;

import client.ApiClient;
import client.ApiException;
import client.Configuration;
import client.Pair;
import client.models.CancelPaymentRequest;
import client.models.CancelPaymentResponse;
import client.models.CapturePaymentRequest;
import client.models.CapturePaymentResponse;
import client.models.CompletePaymentRequest;
import client.models.CompletePaymentResponse;
import client.models.CreatePaymentResponse;
import client.models.PausePaymentResponse;
import client.models.PaymentExecutionRequest;
import client.models.RefundPaymentResponse;
import client.models.RefundRequest;

public class PaymentExecutionApi {


  private ApiClient apiClient;

  public PaymentExecutionApi() {
    this(Configuration.getDefaultApiClient());
  }

  public PaymentExecutionApi(ApiClient apiClient) {
    this.apiClient = apiClient;
  }

  public ApiClient getApiClient() {
    return apiClient;
  }

  public void setApiClient(ApiClient apiClient) {
    this.apiClient = apiClient;
  }

  /**
   * Cancel a Payment
   * This endpoint can be used to reverse the payment associated with this Checkout. The Cancel is only possible for the entire amount of the payment and not partial payments.  In the light of card payments, reversing an authorization that is not needed will prevent you from having to pay a fee/penalty for unused authorization requests. Whilst scheme regulations require that acquirers and PSPs support authorization reversals, there are no rules towards issuers mandating them to process the reversal advice. Therefore, there is no guarantee the authorization hold is released. The authorization reversal can only be performed by the card issuer, and under no circumstances will we be responsible for performing the authorization reversal.  The cancellationReason is mandatory for BNPL payment methods (paymentProductId 3390, 3391 and 3392). For other payment methods the cancellationReason is not mandatory but can be used for reporting and reconciliation purposes.
   * @param merchantId The merchantId identifies uniquely the merchant. (required)
   * @param commerceCaseId Unique identifier of a Commerce Case. (required)
   * @param checkoutId Unique identifier of a Checkout (required)
   * @param paymentExecutionId Unique identifier of a paymentExecution (required)
   * @param cancelPaymentRequest  (required)
   * @return CancelPaymentResponse
   * @throws ApiException if fails to make API call
   */
  public CancelPaymentResponse cancelPaymentExecution(String merchantId, UUID commerceCaseId, UUID checkoutId, UUID paymentExecutionId, CancelPaymentRequest cancelPaymentRequest) throws ApiException {
    return this.cancelPaymentExecution(merchantId, commerceCaseId, checkoutId, paymentExecutionId, cancelPaymentRequest, Collections.emptyMap());
  }


  /**
   * Cancel a Payment
   * This endpoint can be used to reverse the payment associated with this Checkout. The Cancel is only possible for the entire amount of the payment and not partial payments.  In the light of card payments, reversing an authorization that is not needed will prevent you from having to pay a fee/penalty for unused authorization requests. Whilst scheme regulations require that acquirers and PSPs support authorization reversals, there are no rules towards issuers mandating them to process the reversal advice. Therefore, there is no guarantee the authorization hold is released. The authorization reversal can only be performed by the card issuer, and under no circumstances will we be responsible for performing the authorization reversal.  The cancellationReason is mandatory for BNPL payment methods (paymentProductId 3390, 3391 and 3392). For other payment methods the cancellationReason is not mandatory but can be used for reporting and reconciliation purposes.
   * @param merchantId The merchantId identifies uniquely the merchant. (required)
   * @param commerceCaseId Unique identifier of a Commerce Case. (required)
   * @param checkoutId Unique identifier of a Checkout (required)
   * @param paymentExecutionId Unique identifier of a paymentExecution (required)
   * @param cancelPaymentRequest  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return CancelPaymentResponse
   * @throws ApiException if fails to make API call
   */
  public CancelPaymentResponse cancelPaymentExecution(String merchantId, UUID commerceCaseId, UUID checkoutId, UUID paymentExecutionId, CancelPaymentRequest cancelPaymentRequest, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = cancelPaymentRequest;
    
    // verify the required parameter 'merchantId' is set
    if (merchantId == null) {
      throw new ApiException(400, "Missing the required parameter 'merchantId' when calling cancelPaymentExecution");
    }
    
    // verify the required parameter 'commerceCaseId' is set
    if (commerceCaseId == null) {
      throw new ApiException(400, "Missing the required parameter 'commerceCaseId' when calling cancelPaymentExecution");
    }
    
    // verify the required parameter 'checkoutId' is set
    if (checkoutId == null) {
      throw new ApiException(400, "Missing the required parameter 'checkoutId' when calling cancelPaymentExecution");
    }
    
    // verify the required parameter 'paymentExecutionId' is set
    if (paymentExecutionId == null) {
      throw new ApiException(400, "Missing the required parameter 'paymentExecutionId' when calling cancelPaymentExecution");
    }
    
    // verify the required parameter 'cancelPaymentRequest' is set
    if (cancelPaymentRequest == null) {
      throw new ApiException(400, "Missing the required parameter 'cancelPaymentRequest' when calling cancelPaymentExecution");
    }
    
    // create path and map variables
    String localVarPath = "/v1/{merchantId}/commerce-cases/{commerceCaseId}/checkouts/{checkoutId}/payment-executions/{paymentExecutionId}/cancel"
      .replaceAll("\\{" + "merchantId" + "\\}", apiClient.escapeString(merchantId.toString()))
      .replaceAll("\\{" + "commerceCaseId" + "\\}", apiClient.escapeString(commerceCaseId.toString()))
      .replaceAll("\\{" + "checkoutId" + "\\}", apiClient.escapeString(checkoutId.toString()))
      .replaceAll("\\{" + "paymentExecutionId" + "\\}", apiClient.escapeString(paymentExecutionId.toString()));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    TypeReference<CancelPaymentResponse> localVarReturnType = new TypeReference<CancelPaymentResponse>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Capture a Payment
   * This endpoint can be used to capture authorized amounts of a payment. The Capture can only be done for Checkouts with status COMPLETED, BILLED or CHARGEDBACKED.          It is possible to perform multiple partial captures by providing an amount that is lower than the total authorized amount.  The cancellationReason is mandatory for BNPL payment methods (paymentProductId 3390, 3391 and 3392) if isFinal is set to true and the amount of the Capture is lower than the authorized amount. For other payment methods the cancellationReason is not mandatory in this case but can be used for reporting and reconciliation purposes.
   * @param merchantId The merchantId identifies uniquely the merchant. (required)
   * @param commerceCaseId Unique identifier of a Commerce Case. (required)
   * @param checkoutId Unique identifier of a Checkout (required)
   * @param paymentExecutionId Unique identifier of a paymentExecution (required)
   * @param capturePaymentRequest  (required)
   * @return CapturePaymentResponse
   * @throws ApiException if fails to make API call
   */
  public CapturePaymentResponse capturePaymentExecution(String merchantId, UUID commerceCaseId, UUID checkoutId, UUID paymentExecutionId, CapturePaymentRequest capturePaymentRequest) throws ApiException {
    return this.capturePaymentExecution(merchantId, commerceCaseId, checkoutId, paymentExecutionId, capturePaymentRequest, Collections.emptyMap());
  }


  /**
   * Capture a Payment
   * This endpoint can be used to capture authorized amounts of a payment. The Capture can only be done for Checkouts with status COMPLETED, BILLED or CHARGEDBACKED.          It is possible to perform multiple partial captures by providing an amount that is lower than the total authorized amount.  The cancellationReason is mandatory for BNPL payment methods (paymentProductId 3390, 3391 and 3392) if isFinal is set to true and the amount of the Capture is lower than the authorized amount. For other payment methods the cancellationReason is not mandatory in this case but can be used for reporting and reconciliation purposes.
   * @param merchantId The merchantId identifies uniquely the merchant. (required)
   * @param commerceCaseId Unique identifier of a Commerce Case. (required)
   * @param checkoutId Unique identifier of a Checkout (required)
   * @param paymentExecutionId Unique identifier of a paymentExecution (required)
   * @param capturePaymentRequest  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return CapturePaymentResponse
   * @throws ApiException if fails to make API call
   */
  public CapturePaymentResponse capturePaymentExecution(String merchantId, UUID commerceCaseId, UUID checkoutId, UUID paymentExecutionId, CapturePaymentRequest capturePaymentRequest, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = capturePaymentRequest;
    
    // verify the required parameter 'merchantId' is set
    if (merchantId == null) {
      throw new ApiException(400, "Missing the required parameter 'merchantId' when calling capturePaymentExecution");
    }
    
    // verify the required parameter 'commerceCaseId' is set
    if (commerceCaseId == null) {
      throw new ApiException(400, "Missing the required parameter 'commerceCaseId' when calling capturePaymentExecution");
    }
    
    // verify the required parameter 'checkoutId' is set
    if (checkoutId == null) {
      throw new ApiException(400, "Missing the required parameter 'checkoutId' when calling capturePaymentExecution");
    }
    
    // verify the required parameter 'paymentExecutionId' is set
    if (paymentExecutionId == null) {
      throw new ApiException(400, "Missing the required parameter 'paymentExecutionId' when calling capturePaymentExecution");
    }
    
    // verify the required parameter 'capturePaymentRequest' is set
    if (capturePaymentRequest == null) {
      throw new ApiException(400, "Missing the required parameter 'capturePaymentRequest' when calling capturePaymentExecution");
    }
    
    // create path and map variables
    String localVarPath = "/v1/{merchantId}/commerce-cases/{commerceCaseId}/checkouts/{checkoutId}/payment-executions/{paymentExecutionId}/capture"
      .replaceAll("\\{" + "merchantId" + "\\}", apiClient.escapeString(merchantId.toString()))
      .replaceAll("\\{" + "commerceCaseId" + "\\}", apiClient.escapeString(commerceCaseId.toString()))
      .replaceAll("\\{" + "checkoutId" + "\\}", apiClient.escapeString(checkoutId.toString()))
      .replaceAll("\\{" + "paymentExecutionId" + "\\}", apiClient.escapeString(paymentExecutionId.toString()));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    TypeReference<CapturePaymentResponse> localVarReturnType = new TypeReference<CapturePaymentResponse>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Complete a Payment
   * For PAYONE Secured Installments (paymentProductId3391) a two-step process is required. The first step is creating a Payment, the second step is completing it by calling this API endpoint.
   * @param merchantId The merchantId identifies uniquely the merchant. (required)
   * @param commerceCaseId Unique identifier of a Commerce Case. (required)
   * @param checkoutId Unique identifier of a Checkout (required)
   * @param paymentExecutionId Unique identifier of a paymentExecution (required)
   * @param completePaymentRequest  (required)
   * @return CompletePaymentResponse
   * @throws ApiException if fails to make API call
   */
  public CompletePaymentResponse completePayment(String merchantId, UUID commerceCaseId, UUID checkoutId, UUID paymentExecutionId, CompletePaymentRequest completePaymentRequest) throws ApiException {
    return this.completePayment(merchantId, commerceCaseId, checkoutId, paymentExecutionId, completePaymentRequest, Collections.emptyMap());
  }


  /**
   * Complete a Payment
   * For PAYONE Secured Installments (paymentProductId3391) a two-step process is required. The first step is creating a Payment, the second step is completing it by calling this API endpoint.
   * @param merchantId The merchantId identifies uniquely the merchant. (required)
   * @param commerceCaseId Unique identifier of a Commerce Case. (required)
   * @param checkoutId Unique identifier of a Checkout (required)
   * @param paymentExecutionId Unique identifier of a paymentExecution (required)
   * @param completePaymentRequest  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return CompletePaymentResponse
   * @throws ApiException if fails to make API call
   */
  public CompletePaymentResponse completePayment(String merchantId, UUID commerceCaseId, UUID checkoutId, UUID paymentExecutionId, CompletePaymentRequest completePaymentRequest, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = completePaymentRequest;
    
    // verify the required parameter 'merchantId' is set
    if (merchantId == null) {
      throw new ApiException(400, "Missing the required parameter 'merchantId' when calling completePayment");
    }
    
    // verify the required parameter 'commerceCaseId' is set
    if (commerceCaseId == null) {
      throw new ApiException(400, "Missing the required parameter 'commerceCaseId' when calling completePayment");
    }
    
    // verify the required parameter 'checkoutId' is set
    if (checkoutId == null) {
      throw new ApiException(400, "Missing the required parameter 'checkoutId' when calling completePayment");
    }
    
    // verify the required parameter 'paymentExecutionId' is set
    if (paymentExecutionId == null) {
      throw new ApiException(400, "Missing the required parameter 'paymentExecutionId' when calling completePayment");
    }
    
    // verify the required parameter 'completePaymentRequest' is set
    if (completePaymentRequest == null) {
      throw new ApiException(400, "Missing the required parameter 'completePaymentRequest' when calling completePayment");
    }
    
    // create path and map variables
    String localVarPath = "/v1/{merchantId}/commerce-cases/{commerceCaseId}/checkouts/{checkoutId}/payment-executions/{paymentExecutionId}/complete"
      .replaceAll("\\{" + "merchantId" + "\\}", apiClient.escapeString(merchantId.toString()))
      .replaceAll("\\{" + "commerceCaseId" + "\\}", apiClient.escapeString(commerceCaseId.toString()))
      .replaceAll("\\{" + "checkoutId" + "\\}", apiClient.escapeString(checkoutId.toString()))
      .replaceAll("\\{" + "paymentExecutionId" + "\\}", apiClient.escapeString(paymentExecutionId.toString()));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    TypeReference<CompletePaymentResponse> localVarReturnType = new TypeReference<CompletePaymentResponse>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Create a Payment
   * This endpoint can be used to create a payment for a specific payment method. The amount of the payment cannot exceed the overall Checkout amount.
   * @param merchantId The merchantId identifies uniquely the merchant. A Checkout has exactly one merchant. (required)
   * @param commerceCaseId Unique identifier of a Commerce Case. (required)
   * @param checkoutId Unique identifier of a Checkout (required)
   * @param paymentExecutionRequest  (required)
   * @return CreatePaymentResponse
   * @throws ApiException if fails to make API call
   */
  public CreatePaymentResponse createPayment(String merchantId, UUID commerceCaseId, UUID checkoutId, PaymentExecutionRequest paymentExecutionRequest) throws ApiException {
    return this.createPayment(merchantId, commerceCaseId, checkoutId, paymentExecutionRequest, Collections.emptyMap());
  }


  /**
   * Create a Payment
   * This endpoint can be used to create a payment for a specific payment method. The amount of the payment cannot exceed the overall Checkout amount.
   * @param merchantId The merchantId identifies uniquely the merchant. A Checkout has exactly one merchant. (required)
   * @param commerceCaseId Unique identifier of a Commerce Case. (required)
   * @param checkoutId Unique identifier of a Checkout (required)
   * @param paymentExecutionRequest  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return CreatePaymentResponse
   * @throws ApiException if fails to make API call
   */
  public CreatePaymentResponse createPayment(String merchantId, UUID commerceCaseId, UUID checkoutId, PaymentExecutionRequest paymentExecutionRequest, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = paymentExecutionRequest;
    
    // verify the required parameter 'merchantId' is set
    if (merchantId == null) {
      throw new ApiException(400, "Missing the required parameter 'merchantId' when calling createPayment");
    }
    
    // verify the required parameter 'commerceCaseId' is set
    if (commerceCaseId == null) {
      throw new ApiException(400, "Missing the required parameter 'commerceCaseId' when calling createPayment");
    }
    
    // verify the required parameter 'checkoutId' is set
    if (checkoutId == null) {
      throw new ApiException(400, "Missing the required parameter 'checkoutId' when calling createPayment");
    }
    
    // verify the required parameter 'paymentExecutionRequest' is set
    if (paymentExecutionRequest == null) {
      throw new ApiException(400, "Missing the required parameter 'paymentExecutionRequest' when calling createPayment");
    }
    
    // create path and map variables
    String localVarPath = "/v1/{merchantId}/commerce-cases/{commerceCaseId}/checkouts/{checkoutId}/payment-executions"
      .replaceAll("\\{" + "merchantId" + "\\}", apiClient.escapeString(merchantId.toString()))
      .replaceAll("\\{" + "commerceCaseId" + "\\}", apiClient.escapeString(commerceCaseId.toString()))
      .replaceAll("\\{" + "checkoutId" + "\\}", apiClient.escapeString(checkoutId.toString()));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    TypeReference<CreatePaymentResponse> localVarReturnType = new TypeReference<CreatePaymentResponse>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Pause a Payment for selected payment methods
   * Defers next dunning step-up after a consumer has announced to send back a shipped order. Merchant intends to do a REFUND call soon.   Currently only applicable for PAYONE Buy Now, Pay Later (BNPL).  * 3390 - PAYONE Secured Invoice * 3391 - PAYONE Secured Installment * 3392 - PAYONE Secured Direct Debit
   * @param merchantId The merchantId identifies uniquely the merchant. (required)
   * @param commerceCaseId Unique identifier of a Commerce Case. (required)
   * @param checkoutId Unique identifier of a Checkout (required)
   * @param paymentExecutionId Unique identifier of a paymentExecution (required)
   * @return PausePaymentResponse
   * @throws ApiException if fails to make API call
   */
  public PausePaymentResponse pausePayment(String merchantId, UUID commerceCaseId, UUID checkoutId, UUID paymentExecutionId) throws ApiException {
    return this.pausePayment(merchantId, commerceCaseId, checkoutId, paymentExecutionId, Collections.emptyMap());
  }


  /**
   * Pause a Payment for selected payment methods
   * Defers next dunning step-up after a consumer has announced to send back a shipped order. Merchant intends to do a REFUND call soon.   Currently only applicable for PAYONE Buy Now, Pay Later (BNPL).  * 3390 - PAYONE Secured Invoice * 3391 - PAYONE Secured Installment * 3392 - PAYONE Secured Direct Debit
   * @param merchantId The merchantId identifies uniquely the merchant. (required)
   * @param commerceCaseId Unique identifier of a Commerce Case. (required)
   * @param checkoutId Unique identifier of a Checkout (required)
   * @param paymentExecutionId Unique identifier of a paymentExecution (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return PausePaymentResponse
   * @throws ApiException if fails to make API call
   */
  public PausePaymentResponse pausePayment(String merchantId, UUID commerceCaseId, UUID checkoutId, UUID paymentExecutionId, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'merchantId' is set
    if (merchantId == null) {
      throw new ApiException(400, "Missing the required parameter 'merchantId' when calling pausePayment");
    }
    
    // verify the required parameter 'commerceCaseId' is set
    if (commerceCaseId == null) {
      throw new ApiException(400, "Missing the required parameter 'commerceCaseId' when calling pausePayment");
    }
    
    // verify the required parameter 'checkoutId' is set
    if (checkoutId == null) {
      throw new ApiException(400, "Missing the required parameter 'checkoutId' when calling pausePayment");
    }
    
    // verify the required parameter 'paymentExecutionId' is set
    if (paymentExecutionId == null) {
      throw new ApiException(400, "Missing the required parameter 'paymentExecutionId' when calling pausePayment");
    }
    
    // create path and map variables
    String localVarPath = "/v1/{merchantId}/commerce-cases/{commerceCaseId}/checkouts/{checkoutId}/payment-executions/{paymentExecutionId}/pause"
      .replaceAll("\\{" + "merchantId" + "\\}", apiClient.escapeString(merchantId.toString()))
      .replaceAll("\\{" + "commerceCaseId" + "\\}", apiClient.escapeString(commerceCaseId.toString()))
      .replaceAll("\\{" + "checkoutId" + "\\}", apiClient.escapeString(checkoutId.toString()))
      .replaceAll("\\{" + "paymentExecutionId" + "\\}", apiClient.escapeString(paymentExecutionId.toString()));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    TypeReference<PausePaymentResponse> localVarReturnType = new TypeReference<PausePaymentResponse>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Refund a Payment
   * This endpoint can be used to refund a payment for the associated Checkout. The Refund can only be done for Checkouts with status BILLED or CHARGEDBACKED.
   * @param merchantId The merchantId identifies uniquely the merchant. (required)
   * @param commerceCaseId Unique identifier of a Commerce Case. (required)
   * @param checkoutId Unique identifier of a Checkout (required)
   * @param paymentExecutionId Unique identifier of a paymentExecution (required)
   * @param refundRequest  (required)
   * @return RefundPaymentResponse
   * @throws ApiException if fails to make API call
   */
  public RefundPaymentResponse refundPaymentExecution(String merchantId, UUID commerceCaseId, UUID checkoutId, UUID paymentExecutionId, RefundRequest refundRequest) throws ApiException {
    return this.refundPaymentExecution(merchantId, commerceCaseId, checkoutId, paymentExecutionId, refundRequest, Collections.emptyMap());
  }


  /**
   * Refund a Payment
   * This endpoint can be used to refund a payment for the associated Checkout. The Refund can only be done for Checkouts with status BILLED or CHARGEDBACKED.
   * @param merchantId The merchantId identifies uniquely the merchant. (required)
   * @param commerceCaseId Unique identifier of a Commerce Case. (required)
   * @param checkoutId Unique identifier of a Checkout (required)
   * @param paymentExecutionId Unique identifier of a paymentExecution (required)
   * @param refundRequest  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return RefundPaymentResponse
   * @throws ApiException if fails to make API call
   */
  public RefundPaymentResponse refundPaymentExecution(String merchantId, UUID commerceCaseId, UUID checkoutId, UUID paymentExecutionId, RefundRequest refundRequest, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = refundRequest;
    
    // verify the required parameter 'merchantId' is set
    if (merchantId == null) {
      throw new ApiException(400, "Missing the required parameter 'merchantId' when calling refundPaymentExecution");
    }
    
    // verify the required parameter 'commerceCaseId' is set
    if (commerceCaseId == null) {
      throw new ApiException(400, "Missing the required parameter 'commerceCaseId' when calling refundPaymentExecution");
    }
    
    // verify the required parameter 'checkoutId' is set
    if (checkoutId == null) {
      throw new ApiException(400, "Missing the required parameter 'checkoutId' when calling refundPaymentExecution");
    }
    
    // verify the required parameter 'paymentExecutionId' is set
    if (paymentExecutionId == null) {
      throw new ApiException(400, "Missing the required parameter 'paymentExecutionId' when calling refundPaymentExecution");
    }
    
    // verify the required parameter 'refundRequest' is set
    if (refundRequest == null) {
      throw new ApiException(400, "Missing the required parameter 'refundRequest' when calling refundPaymentExecution");
    }
    
    // create path and map variables
    String localVarPath = "/v1/{merchantId}/commerce-cases/{commerceCaseId}/checkouts/{checkoutId}/payment-executions/{paymentExecutionId}/refund"
      .replaceAll("\\{" + "merchantId" + "\\}", apiClient.escapeString(merchantId.toString()))
      .replaceAll("\\{" + "commerceCaseId" + "\\}", apiClient.escapeString(commerceCaseId.toString()))
      .replaceAll("\\{" + "checkoutId" + "\\}", apiClient.escapeString(checkoutId.toString()))
      .replaceAll("\\{" + "paymentExecutionId" + "\\}", apiClient.escapeString(paymentExecutionId.toString()));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] {  };

    TypeReference<RefundPaymentResponse> localVarReturnType = new TypeReference<RefundPaymentResponse>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

}
